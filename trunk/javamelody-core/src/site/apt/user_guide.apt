	-----
	Description et documentation de Java Melody : monitoring d'applications Java EE
	-----
	Auteur : Emeric Vernat (evernat@free.fr)
	-----
	2009-01-01
	-----

~~ http://maven.apache.org/doxia/references/apt-format.html

Description et documentation de Java Melody : monitoring d'applications Java EE

	({{{user_guide_en.html} English }})

	Cet outil de monitoring a pour but de monitorer les serveurs d'applications Java / JavaEE en recette et en production.

	Ce n'est pas un outil de simulation de requêtes utilisateur,
	c'est un outil de mesure et de statistiques sur le fonctionnement réel d'une application
	selon l'usage qui en est fait par les utilisateurs.

	Le monitoring est en grande partie basé sur des statistiques de requêtes et sur des courbes d'évolution.
	
	Il permet ainsi d'améliorer les applications en recette et en production et d'aider à :
	
	* factualiser les temps de réponse moyens et les nombres d'exécutions
	
	* prendre des décisions quand les tendances sont mauvaises, avant que les problèmes ne soient trop graves
	
	* optimiser sur la base des temps de réponse les plus pénalisants
	
	* trouver les causes à l'origine des temps de réponse
	
	* vérifier l'amélioration réelle après des optimisations

	[]

	Licence : LGPL
	
	URL : http://javamelody.googlecode.com/
	
	Version Java requise en exécution :

	* 1.5 minimum

	* 1.6 ou 1.7 recommandé pour fonctions complémentaires (heap dump, histogramme mémoire, stack traces et
	system load average)
	
	* JDK ou JRE de Sun ou JRockit d'Oracle/BEA ou J9 d'IBM

	[]

	Version de serveur requise en exécution : api servlet 2.4 minimum (ou JavaEE 1.4), 
		comme Tomcat 5.5, 6 ou 7, GlassFish v2 ou v3, JBoss 4, 5, 6 ou 7, Jonas 4 ou 5, Jetty 6 ou 7, WebLogic 9, 10 ou 11

	Dépendance requise : JRobin (LGPL) pour les courbes d'évolution
	
	Dépendances optionnelles : iText (LGPL ou MPL) pour les rapports au format pdf en plus de html,
		Spring AOP, AOP alliance, Spring core, Spring beans et Commons logging pour le monitoring des beans Spring,
		Ehcache pour le monitoring des caches, Quartz pour le monitoring des jobs en batchs

	Langage : français, anglais, allemand, portugais et chinois

	Navigateur : Le rapport html de JavaMelody est optimisé pour {{{http://www.mozilla.com}Firefox}},
	{{{http://www.google.com/chrome}Chrome}} ou MSIE8 (MSIE7 non recommandé).

	{{{http://www.slideshare.net/djkarlsen/significance-of-metrics} Roots conference slides by David Karlsen}}


* Plugin Hudson / Jenkins

	Si vous voulez monitorer un serveur {{{http://hudson-ci.org/}Hudson}} ou un serveur {{{http://jenkins-ci.org/}Jenkins}},
	vous pouvez installer JavaMelody en quelques cliques
	par l'intermédiaire d'un plugin Hudson / Jenkins.
	Pour cela, ouvrer Hudson / Jenkins et cliquer "Administrer Hudson / Jenkins", "Gestion des plugins", "Disponibles"
	puis cocher le plugin appelé "Monitoring" et cliquer le bouton "Installer" en bas de la page.
	Redémarrer Hudson / Jenkins après l'installation du plugin.
	Vous pouvez alors ouvrir le rapport à partir de la page "Administrer Hudson / Jenkins"
	ou à partir de l'adresse <<<http://host/monitoring>>>.
	Vous pouvez aussi ouvrir le rapport pour les nodes à partir de l'adresse <<<http://host/monitoring/nodes>>>
	C'est tout.

* Plugin Atlassian JIRA, Confluence et Bamboo

	Si vous voulez monitorer un serveur {{{http://www.atlassian.com/software/jira/}JIRA}},
	{{{http://www.atlassian.com/software/confluence/}Confluence}}
	ou {{{http://www.atlassian.com/software/bamboo/}Bamboo}}, vous pouvez installer JavaMelody facilement
	par l'intermédiaire d'un plugin JIRA/Confluence/Bamboo.
	Pour cela, {{{https://plugins.atlassian.com/plugin/details/20909}télécharger}} le fichier jar du plugin
	et copier le fichier dans le répertoire <<<JIRA x.x.x/atlassian-jira/WEB-INF/lib>>> pour JIRA,
	<<<Bamboo/webapp/WEB-INF/lib>>> pour Bamboo
	ou par l'intermédiaire du "Plugin manager" dans le menu d'administration pour Confluence.
	Redémarrer le serveur.
	Vous pouvez alors ouvrir le rapport à partir de l'adresse <<<http://host:port/monitoring>>>
	(le lien "Monitoring" est également disponible dans le menu "Administration").
	C'est tout en général.
	
	Notes : Les connexions jdbc et les requêtes SQL sont monitorées automatiquement dans JIRA 4.3.x ou avant,
	et elles sont monitorées dans Confluence et Bamboo si une datasource jdbc est utilisée et non la
	connexion jdbc directe par défaut.
	
	Pour configurer Confluence avec une datasource, voir {{{http://confluence.atlassian.com/display/DOC/Database+Configuration}ici}}.
	
	Pour configurer Bamboo avec une datasource, voir {{{http://confluence.atlassian.com/display/BAMBOO/Connecting+Bamboo+to+an+external+database}ici}}.
	En alternative pour Bamboo, il est possible de remplacer le driver hsqldb par défaut par le suivant dans
	<<<bamboo-home/bamboo.cfg.xml>>>:
	<<<
	<property name="hibernate.connection.driver">org.hsqldb.jdbcDriver</property>
    <property name="hibernate.connection.driver_class">net.bull.javamelody.JdbcDriver</property>
    >>>

	Depuis JIRA 4.4, la configuration de la base de données a été changée par Atlassian comme indiqué {{{http://confluence.atlassian.com/display/JIRA/JIRA+4.4+Upgrade+Notes#JIRA44UpgradeNotes-MigratingYourDatabaseConfiguration}ici}}.
	Si vous utilisez JIRA 4.4 ou plus, il est nécessaire de modifier le fichier "Application Data/JIRA/dbconfig.xml": remplacez simplement la ligne suivante
	<<<
	<driver-class>xyz</driver-class>
    >>>
	avec les 2 lignes suivantes
	<<<
	<driver-class>net.bull.javamelody.JdbcDriver</driver-class>
	<connection-properties>driver=xyz</connection-properties>
    >>>
	où "xyz" est le driver jdbc utilisé selon votre base de données (par exemple, "org.hsqldb.jdbcDriver" pour la base de données par défaut)
	
	Ou vous pouvez utiliser une datasource jndi dans JIRA 4.4 ou plus et elle sera automatiquement monitorée.
	Pour utiliser une datasource jndi, remplacez dans le fichier dbconfig.xml "<jdbc-datasource>...</jdbc-datasource>"
	par "<jndi-datasource><jndi-name>java:comp/env/jdbc/JiraDS</jndi-name></jndi-datasource>" (faire une sauvegarde auparavant),
	et ajoutez un élément Resource de datasource dans l'élément Context du fichier de Tomcat "JIRA/conf/server.xml".
	Voir cet {{{http://confluence.atlassian.com/display/JIRA043/Connecting+JIRA+to+MySQL#ConnectingJIRAtoMySQL-51ConfigureyourapplicationservertoconnecttoMySQL}exemple de datasource pour mysql}} ;
	les valeurs dans votre élément Resource doivent s'inspirer des valeurs qui viennent d'être enlevées de votre fichier dbconfig.xml.
	Et ainsi la datasource jndi sera automatiquement monitorée après un redémarrage.


	Un rapport hebdomadaire, quotidien ou mensuel au format pdf peut être envoyé par mail à un ou plusieurs responsable(s) technique(s).
	Cela est expliqué dans le chapitre "Rapports hebdomadaires, quotidiens ou mensuels par mail".
	
	Par exemple, pour JIRA:
	
	Copier les fichiers "mail-1.4.4.jar" et "activation-1.1.1.jar" depuis le répertoire "JIRA/atlassian-jira/WEB-INF/lib/" directory
	vers le répertoire "JIRA/lib/".
	Et ajouter les lignes suivantes dans l'élément Context du fichier "JIRA/conf/server.xml":
	
+-------------------------------+
...
<Context ... >
	...
	<Resource name="mail/MySession" auth="Container" type="javax.mail.Session"
		mail.smtp.host="<serveur smtp>"
		mail.smtp.user="<login>"
		mail.from="Plugin JIRA JavaMelody"
	/>
	<Parameter name='javamelody.admin-emails' value='admin1@societe.fr,admin2@societe.fr' override='false'/>
	<Parameter name='javamelody.mail-session' value='java:comp/env/mail/MySession' override='false'/>
	<Parameter name='javamelody.mail-periods' value='day,week,month' override='false'/>
</Context>
...
+-------------------------------+

* Plugin Grails

	Si vous voulez monitorer une application développée avec {{{http://www.grails.org}Grails}}, vous pouvez installer JavaMelody en une commande
	par l'intermédiaire d'un plugin Grails : {{{http://www.grails.org/plugin/grails-melody}JavaMelody Grails plugin}}.
	Pour cela, il suffit d'exécuter la commande indiquée dans l'onglet Installation du plugin.

* Mise en oeuvre JavaMelody

	Une valeur importante du monitoring est une installation très simple et rapide.
	Cela passe en général par une intégration par le fournisseur informatique sans aucune intervention du client.
	
	Cette intégration peut se faire en moins 10 minutes, grâce à la détection automatique de l'environnement par le monitoring :
	il suffit de copier 2 fichiers jar et d'ajouter 10 lignes dans un fichier xml.
	
	Puis cette intégration pourra être complétée par du paramétrage en fonction des besoins.

	Si vous déployez votre application avec un fichier war ou avec un répertoire équivalent,
	suivez les chapitres suivants.
	
	Mais si vous déployez votre application avec un fichier ear, probablement parce que vous utilisez des EJBs,
	suivez la {{{user_guide_advanced.html} documentation avancée}}.
	
	Remarque: le fichier javamelody.war n'est pas utilisé pour l'installation ici.
	
** 1. Fichiers Jar

	Copier les fichiers <<<javamelody.jar>>> et <<<jrobin-x.jar>>>, situés à la racine du fichier javamelody.zip fourni,
	vers le répertoire WEB-INF/lib du war de la webapp à monitorer
	
	Ou si vous utilisez Maven, ajouter la dépendance javamelody-core. 

** 2. Fichier <<<web.xml>>>

	Si votre serveur d'application est compatible avec l'API Servlet 3.0 (comme tomcat 7, glassfish v3 ou jboss 6),
	ce paragraphe est en général inutile, vous pouvez passer de suite au démarrage du serveur dans
	le paragraphe suivant, excepté si vous utilisez un fichier web.xml sans version="3.0".
	Sinon ajouter les lignes suivantes dans le fichier <<<WEB-INF/web.xml>>> du war de la webapp,
	avant la description de votre servlet :

+-------------------------------+
	<filter>
		<filter-name>monitoring</filter-name>
		<filter-class>net.bull.javamelody.MonitoringFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>monitoring</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	<listener>
		<listener-class>net.bull.javamelody.SessionListener</listener-class>
	</listener>
+-------------------------------+

	Si ces lignes sont ajoutées dans une webapp de type Servlet API 3.0,
	il est possible d'ajouter aussi <<< <async-supported>true</async-supported> >>> dans le filtre
	pour supporter les requêtes asynchrones.

** 3. Premiers résultats

	Vous pouvez dès à présent consulter le monitoring : déployer le war et ouvrir la page suivante dans un navigateur web après avoir
	démarré le serveur :

	<<<http://<host>/<context>/monitoring>>>
	
	où <host> est le nom du serveur où la webapp est déployée, suivi éventuellement du port (par exemple localhost:8080)
	et où <context> est le nom du contexte de la webapp que vous avez configuré au moment du déploiement de celle-ci.
	
	Dans le cas où le démarrage du serveur ne fonctionne pas et qu'une erreur est présente dans
	la sortie du serveur concernant "window server" (en particulier si Mac OSX server est utilisé),
	ajouter la propriété système "-Djava.awt.headless=true" (commande de lancement java ou selon le
	cas interface d'administration du serveur ou $CATALINA_HOME/conf/catalina.properties si tomcat).
	Et redémarrer le serveur.
	
	Vous pouvez ensuite compléter le paramétrage comme ci-dessous en fonction des besoins.

** 4. Génération de rapports PDF

	Pour générer des rapports PDF en plus des rapports html, il est nécessaire d'ajouter la librairie iText
	(licence LGPL ou MPL, le fichier jar iText seul suffit, sans les autres dépendances comme iText-rtf)
	
	Copier le fichier <<<itext-2.1.7.jar>>>, situé dans le répertoire <<<src/test/test-webapp/WEB-INF/lib/>>> du fichier javamelody.zip fourni,
	vers le répertoire WEB-INF/lib du war de la webapp à monitorer. Le lien PDF sera ensuite disponible en haut du rapport html.

** 5. Compléments <<<web.xml>>>

	<<<url-pattern>>> dans le fichier <<<web.xml>>> ci-dessus peut être adapté pour ne monitorer que
	certaines urls, éventuellement avec plusieurs mappings sur le même filtre.
	
	Par exemple, il est possible d'utiliser les <<<filter-mapping>>>s avec les <<<url-pattern>>>s
	suivants pour ne monitorer que les urls comme /servlet1/* et /servlet2/*, mais pas les autres
	comme /static/* :

+-------------------------------+
	<filter>
		<filter-name>monitoring</filter-name>
		<filter-class>net.bull.javamelody.MonitoringFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>monitoring</filter-name>
		<url-pattern>/servlet1/*</url-pattern>
	</filter-mapping>
	<filter-mapping>
		<filter-name>monitoring</filter-name>
		<url-pattern>/servlet2/*</url-pattern>
	</filter-mapping>
	<filter-mapping>
		<filter-name>monitoring</filter-name>
		<url-pattern>/monitoring</url-pattern>
	</filter-mapping>
	<listener>
		<listener-class>net.bull.javamelody.SessionListener</listener-class>
	</listener>
+-------------------------------+

	Note: <<<url-pattern>>> doit obligatoirement "contenir" l'url /monitoring pour avoir les rapports.

	En alternative, il est possible d'utiliser un seul <<<filter-mapping>>> et un paramètre de
	filtre avec une {{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html} expression régulière}}
	peut être ajouté avant <<< </filter> >>> pour exclure certaines urls, par exemple :

+-------------------------------+
	<filter>
		<filter-name>monitoring</filter-name>
		<filter-class>net.bull.javamelody.MonitoringFilter</filter-class>
		
		<init-param>
			<param-name>url-exclude-pattern</param-name>
			<param-value>/static/.*</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>monitoring</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	<listener>
		<listener-class>net.bull.javamelody.SessionListener</listener-class>
	</listener>
+-------------------------------+

** 6. Paramètres optionnels

	Des paramètres peuvent éventuellement être configurés. Ils peuvent être définis par ordre de priorité croissant :

	* dans les paramètres d'initialisation du filtre

	  (fichier <<<web.xml>>> dans la webapp), par exemple:

+-------------------------------+
	<filter>
		<filter-name>monitoring</filter-name>
		<filter-class>net.bull.javamelody.MonitoringFilter</filter-class>
		<init-param>
			<param-name>log</param-name>
			<param-value>true</param-value>
		</init-param>
	</filter>
	...
+-------------------------------+

	* dans les paramètres du contexte de la webapp avec le préfixe <<<javamelody.>>>

	  (fichier xml de contexte dans Tomcat ou dans Glassfish), par exemple:
	  
+-------------------------------+
	<?xml version="1.0" encoding="UTF-8" ?>
	<Context docBase="<pathto>/mywebapp.war" path="mywebapp" reloadable="false" >
		<Parameter name='javamelody.log' value='true' override='false'/>
	</Context>
+-------------------------------+

	* dans les propriétés systèmes avec le préfixe <<<javamelody.>>>

	  (commande de lancement java ou selon le cas interface d'administration
	  ou $CATALINA_HOME/conf/catalina.properties si tomcat), par exemple:

+-------------------------------+
	... -Djavamelody.log=true
+-------------------------------+

	[]

	Le paramètre <<<system-actions-enabled>>> (<<<true>>> par défaut) permet d'activer
	ou de désactiver les actions systèmes telles que <ramasse-miettes>, <sessions http>, <heap dump>,
	<histogramme mémoire>, <processus>, <arbre jndi>, <connexions jdbc ouvertes>, <base de données>
	en bas du rapport.
	Ces actions ont des confirmations quand nécessaire.

	Le paramètre <<<url-exclude-pattern>>> est une
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html} expression régulière}}
	pour exclure certaines urls du monitoring comme indiqué ci-dessus.

	Le paramètre <<<http-transform-pattern>>> est une
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html} expression régulière}}
	pour transformer les descriptions des requêtes http et pour supprimer des parties variables
	(identifiants d'objets par exemple) afin de permettre l'agrégation sur ces requêtes

	De même, le paramètre <<<sql-transform-pattern>>> est une
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html} expression régulière}}
	pour transformer les descriptions des requêtes sql (identifiants non bindés dans une clause in par exemple)
	afin de permettre l'agrégation sur ces requêtes.

	Et les paramètres <<<ejb-transform-pattern>>>, <<<spring-transform-pattern>>>, <<<guice-transform-pattern>>>,
	<<<error-transform-pattern>>>, <<<log-transform-pattern>>>, <<<job-transform-pattern>>>,
	<<<jsf-transform-pattern>>>, <<<struts-transform-pattern>>> et <<<jsp-transform-pattern>>> permettent de transformer les descriptions des méthodes ejb3,
	des méthodes spring, des méthodes guice, des erreurs systèmes http, des logs d'erreurs systèmes,
	des noms de jobs, des actions jsf, des actions struts, ou des pages jsp
	(pour agréger par composants ejb au lieu d'agréger par méthodes ejb par exemple).
	
	Le paramètre <<<displayed-counters>>> permet de modifier les compteurs affichés pour les
	statistiques et les graphiques (<<<http,sql,error,log>>> par défaut). Les compteurs affichés 
	par défaut sont donc ceux de codes http, sql, error et log. Les compteurs de codes jsf, struts, jsp, ejb,
	spring, guice et services s'affichent automatiquement quand ils sont utilisés (voir ci-dessous
	pour ejb, spring, guice ou struts et dans le guide utilisateur avancé pour les services sans ejb ni spring
	ni guice). Le paramètre <<<displayed-counters>>> permet donc de cacher certains compteurs avec
	par exemple la valeur <<<http,sql,ejb,spring>>>.

	Le paramètre <<<log>>> permet d'activer les logs des requêtes http au niveau INFO (<<<false>>>
	par défaut). Les requêtes http seront logguées avec la durée et la taille de la réponse
	dans la catégorie de log correspondant au nom du filtre paramétré dans le fichier <<<web.xml>>>,
	en utilisant Logback ou Log4J si présent dans votre application, ou en utilisant java.util.logging sinon.

	Le paramètre <<<storage-directory>>> est le nom du répertoire de stockage (javamelody par défaut).
	Si le nom du répertoire commence par '/', on considère que c'est un chemin absolu,
	sinon on considère que c'est un chemin relatif par rapport au répertoire temporaire
	(<temp> dans <<<TOMCAT_HOME>>> pour tomcat).
	Si ce paramètre change il est conseillé de renommer le répertoire physique en même temps.

	Le paramètre <<<resolution-seconds>>> est la résolution des courbes en secondes (60 par défaut).
	Une résolution entre 60 et 600 est recommandée (c'est-à-dire 1 à 10 minutes).
	Si ce paramètre diminue, il convient de supprimer les fichiers <<<*.rrd>>> stockés pour qu'il soit pris en compte.

	Les paramètres <<<warning-threshold-millis>>> et <<<severe-threshold-millis>>> sont les seuils en millisecondes
	(moyenne globale + 1 écart-type et moyenne globale + 2 * écart-type par défaut,
	ce fonctionnement par défaut permet d'avoir des seuils dynamiques qui indiquent les requêtes ayant
	des temps moyens inhabituels quelle que soit l'application).
	Au-delà des seuils les temps moyens sont affichés en orange ou en rouge et sont décomptés dans les tableaux
	de synthèse avec leurs pourcentages par temps moyens, hits, etc.
	Ces paramétrages de seuil peuvent servir de base pour un SLA (niveau de service) d'une application, dans lequel
	des contraintes peuvent être définies telles que "temps de traitement inférieurs à 2s pour 90% des requêtes http".

	Le paramètre <<<monitoring-path>>> (<<</monitoring>>> par défaut) permet de changer le chemin dans l'URL d'accès
	au rapport du monitoring. Par exemple, <<<http://.../admin/performance>>> au lieu de <<<http://.../monitoring>>>
	
	Le paramètre <<<no-database>>> permet de désactiver le monitoring des connexions jdbc,
	le monitoring des requêtes sql et les rapports sur la base de données. Le mettre à true
	pour désactiver tout cela.
	
	Le paramètre <<<disabled>>> (<<<false>>> par défaut) permet de désactiver le monitoring.
	Cela permet par exemple de désactiver le monitoring temporairement ou sur certains serveurs,
	à partir du contexte Tomcat ou des propriétés systèmes sans modifier le fichier <<<web.xml>>>
	ni le war de la webapp monitorée.

** 7. JDBC

	Si une DataSource, dont le nom JNDI est de la forme "jdbc/MaDataSource", est configurée dans le serveur d'application
	(contexte xml de la webapp dans Tomcat par exemple), les requêtes sql seront automatiquement monitorées en plus des requêtes http
	sans nécessiter de paramétrage (testé en Tomcat 5.5 et 6, glassfish 3, jboss 5, weblogic 11g, jetty 6).
	En remarque, si JndiObjectFactoryBean est utilisé pour la DataSource dans Spring, alors SessionListener doit être
	avant ContextLoaderListener dans le fichier web.xml ou bien monitoring-spring.xml doit être utilisé comme dit ci-dessous.

	Si un driver jdbc est utilisé directement sans DataSource, il faut déclarer 'net.bull.javamelody.JdbcDriver'
	comme classe de driver et il faut ajouter la propriété jdbc 'driver' avec pour valeur la classe du vrai driver.
	Par exemple, si vous utiliser un fichier hibernate.cfg.xml (sans hibernate.connection.datasource) :

+-------------------------------+
	<property name="hibernate.connection.driver_class">net.bull.javamelody.JdbcDriver</property>
	<property name="hibernate.connection.driver">com.mysql.jdbc.Driver</property>
	<property name="hibernate.connection.url">jdbc:mysql://localhost:3306/myschema</property>
	<property name="hibernate.connection.username">myuser</property>
	<property name="hibernate.connection.password">mypassword</property>
+-------------------------------+

	Si une DataSource est utilisée mais que son nom JNDI n'est pas de la forme "jdbc/MaDataSource" ou que celle-ci
	n'est pas dans un des contextes JNDI "java:comp/env/" ou "java:/" habituels, alors vous pouvez ajouter le paramètre optionnel
	<<<datasources>>> (par une propriété système, un paramètre du contexte ou du filtre)
	pour définir le nom JNDI de la datasource utilisée par l'application.
	S'il y a plusieurs datasources, ce paramètre peut contenir les noms JNDI des datasources
	séparés par des virgules.
	Si un serveur Jonas v5 est utilisé, le monitoring des datasources fonctionne
	mais il semble nécessaire d'utiliser le paramètre <<<datasources>>> pour les déclarer.
	
	Par exemple, pour une propriété système au lancement du serveur:
	
	<<<-Djavamelody.datasources=java:comp/env/myapp/MaDataSource>>>
	
	Si une DataSource est définie par l'intermédiaire d'un fichier xml de contexte Spring,
	comme par exemple <<< <bean class="org.apache.commons.dbcp.BasicDataSource">...</bean> >>>
	ou <<< <bean class="org.springframework.jndi.JndiObjectFactoryBean">...</bean> >>>,
	la DataSource peut être monitorée également, avec un post-processor Spring.
	Assurez-vous que le fichier de configuration Spring (<<<net/bull/javamelody/monitoring-spring.xml>>>,
	inclus dans le jar fourni) est chargé parmi un des premiers fichiers de configuration.
	Par exemple, si vous utilisez <<<org.springframework.web.context.ContextLoaderListener>>> dans
	votre fichier <<<web.xml>>>, le paramètre de contexte <<<contextConfigLocation>>> ressemblera à :

+-------------------------------+
	<context-param>
	  <param-name>contextConfigLocation</param-name>
	  <param-value>
		classpath:net/bull/javamelody/monitoring-spring.xml
		classpath:context/services.xml
		classpath:context/data-access-layer.xml
		/WEB-INF/applicationContext.xml
	  </param-value>
	</context-param>
+-------------------------------+

** 8. Façades métiers (fichier ejb-jar.xml si EJB3)

	Si l'application à monitorer contient des façades métiers en EJB3 (Java EE 5) avec des annotations <<<@Stateless>>>,
	<<<@Stateful>>> ou <<<@MessageDriven>>>, un compteur peut être créé pour les statistiques d'exécution de méthodes.
	Il n'est pas conseillé pour autant de monitorer les exécutions de toutes les méthodes des beans EJB3 et en particulier
	les méthodes de très faible granularité comme les getters d'entités, au risque d'introduire un surcoût en temps de réponse.
	Pour configurer cela, déclarer dans votre fichier <<<ejb-jar.xml>>> l'intercepteur ejb3 comme dans l'exemple suivant :

+-------------------------------+
	<ejb-jar
		xmlns = "http://java.sun.com/xml/ns/javaee"
		version = "3.0"
		xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd"
	>
		<interceptors>
			<interceptor>
				<interceptor-class>net.bull.javamelody.MonitoringInterceptor</interceptor-class>
			</interceptor>
		</interceptors>
		<assembly-descriptor>
			<interceptor-binding>
				<ejb-name>*</ejb-name>
				<interceptor-class>net.bull.javamelody.MonitoringInterceptor</interceptor-class>
			</interceptor-binding>
		</assembly-descriptor>
	</ejb-jar>
+-------------------------------+

	ou

+-------------------------------+
	<ejb-jar
		xmlns = "http://java.sun.com/xml/ns/javaee"
		version = "3.0"
		xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd"
	>
		<interceptors>
			<interceptor>
				<interceptor-class>net.bull.javamelody.MonitoringInterceptor</interceptor-class>
			</interceptor>
		</interceptors>
		<assembly-descriptor>
			<interceptor-binding>
				<ejb-name>FacadeBean1</ejb-name>
				<interceptor-class>net.bull.javamelody.MonitoringInterceptor</interceptor-class>
			</interceptor-binding>
			<interceptor-binding>
				<ejb-name>FacadeBean2</ejb-name>
				<interceptor-class>net.bull.javamelody.MonitoringInterceptor</interceptor-class>
			</interceptor-binding>
		</assembly-descriptor>
	</ejb-jar>
+-------------------------------+

	Dans ce fichier, il est possible d'utiliser * pour tous les ejb ou bien de lister les ejb qui doivent être monitorés.
	Si vous avez plusieurs fichiers ejb-jar.xml, configurer l'intercepteur dans chacun d'eux en conséquence.
	Ou alors, sans modifier le fichier ejb-jar.xml, il est possible d'ajouter l'annotation @Interceptor dans les sources
	java des implémentations d'ejb.

** 9. Façades métiers (si Spring)

	Si l'application à monitorer contient des façades métiers ou autres objets configurés avec Spring,
	un compteur peut être créé pour les statistiques d'exécution de méthodes. Il n'est pas conseillé
	pour autant de monitorer les exécutions de toutes les méthodes des beans Spring et en particulier les méthodes
	de très faible granularité comme les getters d'entités, au risque d'introduire un surcoût en temps de réponse.

	Etape 1 : Pour configurer le monitoring des beans Spring, ajouter la dépendance spring-aop
	(dans pom.xml si maven).
	
	Etape 2 : Assurez-vous que le fichier de configuration Spring 
	(<<<net/bull/javamelody/monitoring-spring.xml>>>, inclus dans le jar fourni) est chargé parmi un
	des premiers fichiers de configuration.

	Par exemple, si vous utilisez <<<org.springframework.web.context.ContextLoaderListener>>> dans
	votre fichier <<<web.xml>>>, le paramètre de contexte <<<contextConfigLocation>>> ressemblera à :

+-------------------------------+
	<context-param>
	  <param-name>contextConfigLocation</param-name>
	  <param-value>
		classpath:net/bull/javamelody/monitoring-spring.xml
		classpath:context/services.xml
		classpath:context/data-access-layer.xml
		/WEB-INF/applicationContext.xml
	  </param-value>
	</context-param>
+-------------------------------+

	Etape 3 : En supposant que les façades métiers possèdent une interface (ou une super-classe) commune 
	<<<com.xyz.someapp.service.Facade>>> et que vous voulez monitorer toutes les méthodes
	de ces façades, ajouter les lignes suivantes dans votre fichier applicationContext.xml :
	
+-------------------------------+
	<bean id="facadeMonitoringAdvisor" class="net.bull.javamelody.MonitoringSpringAdvisor">
		<property name="pointcut">
			<bean class="net.bull.javamelody.MonitoredWithInterfacePointcut">
				<property name="interfaceName" value="com.xyz.someapp.service.Facade" />
			</bean>
		</property>
	</bean>
+-------------------------------+
	
	Comme Spring ne configure le monitoring que pour les beans spring, assurez vous que ces classes
	sont instanciées par l'intermédiaire de Spring
	(c'est-à-dire déclarez les en tant que bean dans un fichier de configuration Spring)
	
	Note : Si vous n'avez pas d'interface (ou de super-classe) commune pour les façades ou si vous
	ne souhaitez pas monitorer toutes les façades, vous pouvez créer et ajouter à vos façades une interface
	<<<com.xyz.someapp.service.Monitored>>> avant de l'utiliser dans votre fichier xml comme
	ci-dessus, ou bien vous pouvez utiliser une des alternatives ci-dessous.
	
	Selon vos préférences, vous avez le choix avec d'autres alternatives à la place de l'étape 3.
	Ces alternatives ne sont pas exclusives : vous pouvez en utiliser une et la compléter par une autre.

	* Utilisation d'une annotation de JavaMelody.
	(implique que la librairie javamelody.jar soit inclus dans le classpath à la compilation)
	Ajouter simplement l'annotation <<<@net.bull.javamelody.MonitoredWithSpring>>> à toutes les
	classes d'implémentations et/ou interfaces et/ou méthodes d'interfaces que vous voulez monitorer,
	sans modifier votre fichier applicationContext.xml.
	Par exemple :
	
+-------------------------------+
	@net.bull.javamelody.MonitoredWithSpring
	public interface Test {
		void maMethode();
	}
	
	or
	
	public interface Test {
		@net.bull.javamelody.MonitoredWithSpring
		void maMethode();
	}
	
	or
	
	@net.bull.javamelody.MonitoredWithSpring
	public class TestImpl implements Test {
		public void maMethode() {
			...
		}
	}
+-------------------------------+

	Cette alternative avec annotation permet aussi de changer les noms des classes affichées dans le
	monitoring. Si le nom affiché par le monitoring pour la classe ou la méthode ne vous convient
	pas, vous pouvez ajouter (name="mon use case") entre parenthèses après l'annotation sur votre
	classe ou sur votre méthode.

	* Utilisation de JdkRegexpMethodPointcut.
	En supposant que les façades métiers puissent être déterminées par une expression régulière,
	ajouter les lignes suivantes dans votre fichier applicationContext.xml en adaptant la valeur
	du pattern de l'expression régulière :
	
+-------------------------------+
	<bean id="facadeMonitoringAdvisor" class="net.bull.javamelody.MonitoringSpringAdvisor">
		<property name="pointcut">
			<bean class="org.springframework.aop.support.JdkRegexpMethodPointcut">
				<property name="pattern" value=".*Facade.*" />
			</bean>
		</property>
	</bean>
+-------------------------------+
	
	* Utilisation de tout autre pointcut fourni par Spring ou écriture de votre propre pointcut.
	Vous pouvez aussi utiliser tout autre {{{http://static.springsource.org/spring/docs/2.5.x/api/index.html}pointcut}}
	fourni par Spring ou écrire le votre.
	Par exemple, vous pouvez créer une classe <<<com.xyz.someapp.service.MonitoringPointcut>>>
	implémentant org.springframework.aop.Pointcut et ajouter les lignes suivantes dans votre fichier
	applicationContext.xml :
	
+-------------------------------+
	<bean id="facadeMonitoringAdvisor" class="net.bull.javamelody.MonitoringSpringAdvisor">
		<property name="pointcut">
			<bean class="com.xyz.someapp.service.MonitoringPointcut" />
		</property>
	</bean>
+-------------------------------+

	[]

	Note : La {{{http://static.springsource.org/spring/docs/2.5.6/reference/aop.html#aop-proxying} documentation }}
	et {{{http://blog.springsource.com/2007/07/19/debunking-myths-proxies-impact-performance/} blog }}
	de Spring AOP recommande d'utiliser des proxys dynamiques du JDK et non CGLIB, ce qui ne devrait
	pas poser de problème pour des façades avec interfaces et implémentations séparées.

	* Alternative pour utiliser AspectJ, dans le cas où les proxys ne fonctionnent pas (merci à {{{http://touk.pl/blog/2011/03/07/javamelody-spring-and-aspectj/} Witek Wołejszo}})
	Parfois les proxys ne peuvent pas fonctionner dans certaines circonstances, par exemple si vous n'utilisez pas d'interfaces.
	Dans ce cas, il est possible d'utiliser AspectJ avec le fichier de contexte suivant
	{{{net/bull/javamelody/monitoring-spring-aspectj.xml}}} à la place de
	{{{net/bull/javamelody/monitoring-spring.xml}}}.
	Vous pouvez alors utiliser l'annotation @MonitoredWithSpring comme indiqué ci-dessus,
	ou vous pouvez utiliser d'autres pointcuts comme le suivant avec une interface commune (ou une super-classe):

+-------------------------------+
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd">

    <aop:config proxy-target-class="true" >
        <aop:advisor advice-ref="monitoringAdvice" pointcut-ref="facadePointcut" />
    </aop:config>

	<bean id="facadePointcut" class="net.bull.javamelody.MonitoredWithInterfacePointcut">
		<property name="interfaceName" value="com.xyz.someapp.service.Facade" />
	</bean>
</beans>
+-------------------------------+

	[]

** 10. Façades métiers (si Guice)

	Si l'application à monitorer contient des façades métiers ou autres objets configurés avec Guice,
	un compteur peut être créé pour les statistiques d'exécution de méthodes. Il n'est pas conseillé
	pour autant de monitorer les exécutions de toutes les méthodes des beans Guice et en particulier les méthodes
	de très faible granularité comme les getters d'entités, au risque d'introduire un surcoût en temps de réponse.
	
	Etape 1 : Pour configurer le monitoring des beans Guice, ajouter la dépendance guice
	(dans pom.xml si maven). En pré-requis pour Guice, il est nécessaire que le jar de javamelody
	soit disponible dans le classpath lors de la compilation.
	
	Etape 2 (par annotations) : Ajouter le module MonitoringGuiceModule à votre module Guice.
	Par exemple :

+-------------------------------+
		final Module testModule = new AbstractModule() {
			/** {@inheritDoc} */
			@Override
			protected void configure() {
				// configuration du monitoring Guice par annotations
				install(new net.bull.javamelody.MonitoringGuiceModule());
				// façade
				bind(TestFacade.class).to(TestFacadeImpl.class);
			}
		};
+-------------------------------+

	Puis ajouter simplement l'annotation <<<@net.bull.javamelody.MonitoredWithGuice>>> à toutes les
	classes d'implémentations (pas sur les interfaces) et/ou méthodes que vous voulez monitorer.
	Par exemple :
	
+-------------------------------+
	@net.bull.javamelody.MonitoredWithGuice
	public class TestImpl implements Test {
		public void maMethode() {
			...
		}
	}
	
	or
	
	public class TestImpl implements Test {
		@net.bull.javamelody.MonitoredWithGuice
		public void maMethode() {
			...
		}
	}
+-------------------------------+
	
	L'annotation permet aussi de changer les noms des classes affichées dans le monitoring.
	Si le nom affiché par le monitoring pour la classe ou la méthode ne vous convient
	pas, vous pouvez ajouter (name="mon use case") entre parenthèses après l'annotation sur votre
	classe ou sur votre méthode.
	
	Comme Guice ne configure le monitoring que pour les beans guice, assurez vous que ces classes
	sont instanciées par l'intermédiaire de Guice
	(c'est-à-dire déclarez les en tant que bind dans votre module Guice)
	
	En alternative à l'étape 2, vous pouvez utiliser une interface ou une super-classe à la place
	des annotations. En supposant que les façades métiers possèdent une interface ou une super-classe
	commune <<<com.xyz.someapp.service.Facade>>> et que vous voules monitorer toutes les méthodes
	de ces façades, ajouter seulement le bindInterceptor suivant dans votre module Guice :
	
+-------------------------------+
		final Module testModule = new AbstractModule() {
			/** {@inheritDoc} */
			@Override
			protected void configure() {
				// configuration du monitoring Guice par interface
				bindInterceptor(Matchers.subclassesOf(com.xyz.someapp.service.Facade.class),
					Matchers.any(), new net.bull.javamelody.MonitoringGuiceInterceptor());
				// façade
				bind(TestFacade.class).to(TestFacadeImpl.class);
			}
		};
+-------------------------------+
	
	Note : Si vous n'avez pas d'interface commune pour les façades ou si vous ne souhaitez pas monitorer
	toutes les façades, vous pouvez créer et ajouter à vos façades une interface
	<<<com.xyz.someapp.service.Monitored>>> avant de l'utiliser dans votre module comme ci-dessus.

** 11. Actions JSF

	Si l'application à monitorer contient des actions JSF basées sur Mojarra (JSF Reference Implementation),
	un compteur est créé automatiquement pour les statistiqes d'exécution des actions.
	Un ActionListener JSF est automatiquement ajouté pour l'application JSF.
	Aucune action de votre part n'est nécessaire pour avoir les statistiques JSF.

** 12. Actions Struts 2

	Si l'application à monitorer contient des actions {{{http://struts.apache.org/} Struts 2}},
	un compteur peut être créé pour les statistiques d'exécution des actions.
	Pour cela il est nécessaire d'ajouter un intercepteur Struts.
	
	Dans votre fichier xml Struts, ajouter les lignes suivantes (ou bien ajouter l'intercepteur
	"monitoring" dans votre stack par défaut) :

+-------------------------------+
	<package name="default" extends="struts-default" >
		<interceptors>
			<interceptor name="monitoring" class="net.bull.javamelody.StrutsInterceptor"/>          

			<interceptor-stack name="myStack">
				<interceptor-ref name="monitoring"/>
				<interceptor-ref name="defaultStack"/>
			</interceptor-stack>
		</interceptors>
		
		<default-interceptor-ref name="myStack"/>
	</package>
+-------------------------------+

	Puis dans tous vos packages Struts, utiliser le package "default" par <<<extends="default">>>

** 13. Jobs en batchs (si Quartz)

	Les jobs sont automatiquement monitorés quand ils sont ordonnancés avec {{{http://www.quartz-scheduler.org/} Quartz}}.

	Mais si ces jobs sont ordonnancés dans Quartz en utilisant
	{{{http://static.springsource.org/spring/docs/2.5.x/reference/scheduling.html} Spring scheduling}},
	il est nécessaire d'ajouter le paramètre javamelody	"quartz-default-listener-disabled" avec la 
	valeur "true" et il est nécessaire d'ajouter la propriété "exposeSchedulerInRepository" avec
	la valeur "true" dans le bean "SchedulerFactoryBean" dans votre fichier applicationContext.xml.

+-------------------------------+
	<bean id="quartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
		<property name="exposeSchedulerInRepository" value="true" />
		...
	</bean>
+-------------------------------+

	Sans cette propriété "exposeSchedulerInRepository", les jobs ordonnancés avec Spring ne seront
	ni monitorés ni affichés dans le rapport.

** 14. Rapports hebdomadaires, quotidiens ou mensuels par mail

	Un rapport hebdomadaire, quotidien ou mensuel au format pdf peut être envoyé par mail à un ou plusieurs responsable(s) technique(s).
	Cette fonctionnalité nécessite la librairie iText dans votre webapp (licence LGPL ou MPL, le fichier jar iText
	seul suffit, sans les autres dépendances comme iText-rtf). Et cela nécessite d'avoir JavaMail et Activation
	de Sun dans les librairies du serveur pour la session mail.

	Pour cela, si la webapp est dans tomcat, télécharger les fichiers jars 
	http://repo1.maven.org/maven2/javax/mail/mail/1.4.1/mail-1.4.1.jar
	et http://repo1.maven.org/maven2/javax/activation/activation/1.1/activation-1.1.jar.
	Puis si tomcat 5.x, placer les 2 fichiers jars dans <tomcat_home>/common/lib
	et si tomcat 6.x, placer les 2 fichiers jars dans <tomcat_home>/lib

	Et ajouter une session mail dans la configuration du serveur d'application avec le nom de votre serveur smtp.
	Par exemple, ajouter dans le contexte tomcat de votre webapp (fichier xml situé dans
	<tomcat_home>/conf/Catalina/localhost/ ou bien dans <tomcat_home>/conf/server.xml)

+-------------------------------+
	<Resource name="mail/MySession" auth="Container" type="javax.mail.Session"
		mail.smtp.host="<serveur smtp>"
		mail.smtp.user="<login>"
		mail.from="MyApplication"
	/>
+-------------------------------+

	où le nom de la session est celui de votre choix et où les propriétés dépendent de votre serveur de mail.
	Si le serveur de mail nécessite une authentification, il est possible d'ajouter dans les propriétés :

+-------------------------------+
	mail.smtp.auth=true
	mail.smtp.password=<password>
+-------------------------------+

	Si le serveur de mail nécessite ssl, remplacer mail.smtp par mail.smtps dans toutes les lignes ci-dessus
	et ajouter une ligne 
	
	<<<mail.transport.protocol=smtps>>>
	
	Des paramètres de configuration supplémentaires peuvent être ajoutés si nécessaire pour la session 
	{{{http://java.sun.com/products/javamail/javadocs/com/sun/mail/smtp/package-summary.html} mail }}

	Puis il est nécessaire d'ajouter la liste des adresses mails séparées par des virgules dans le paramètre
	<<<admin-emails>>>, dans le fichier <<<web.xml>>> ou dans le contexte tomcat ou en propriété système
	comme pour les paramètres optionnels ci-dessus.
	
	Et il faut ajouter également le nom de la session mail dans le paramètre <<<mail-session>>>.
	Par exemple, pour le contexte tomcat de votre webapp :

+-------------------------------+
	<Parameter name='javamelody.admin-emails' value='admin1@societe.fr,admin2@societe.fr' override='false'/>
	<Parameter name='javamelody.mail-session' value='mail/MySession' override='false'/>
+-------------------------------+

	Par défaut, le rapport est envoyé hebdomadairement (une fois par semaine).
	Il est possible d'adapter cela au niveau de supervision qui est souhaité.
	Par exemple, il est possible de l'envoyer quotidiennement (tous les jours),
	mensuellement, ou une combinaison entre quotidiennement, hebdomadairement et mensuellement.
	
	Pour cela, ajouter le paramètre <<<mail-periods>>> avec les périodes "day", "week" ou "month" séparées par des virgules.
	Par exemple, pour le contexte tomcat de votre webapp avec une période quotidienne :

+-------------------------------+
	<Parameter name='javamelody.mail-periods' value='day' override='false'/>
+-------------------------------+

	Ou pour des périodes quotidienne, hebdomadaire et mensuelle :

+-------------------------------+
	<Parameter name='javamelody.mail-periods' value='day,week,month' override='false'/>
+-------------------------------+
	
	Au final, le contexte tomcat de votre webapp peut ressembler à celui-ci :
	
+-------------------------------+
<?xml version="1.0" encoding="UTF-8" ?> 
<Context docBase="/path_to_mywebapp/mywebapp.war" path="mywebapp" reloadable="false" > 
	<Resource name="mail/MySession" auth="Container" type="javax.mail.Session"
		mail.smtp.host="<serveur smtp>"
		mail.smtp.user="<login>"
		mail.from="MyApplication"
	/>
	<Parameter name='javamelody.admin-emails' value='admin1@societe.fr,admin2@societe.fr' override='false'/>
	<Parameter name='javamelody.mail-session' value='mail/MySession' override='false'/>
	<Parameter name='javamelody.mail-periods' value='day,week,month' override='false'/>
</Context>
+-------------------------------+	

	Après le démarrage du serveur, il est possible de tester l'envoi de mail en appelant cette action:
	http://<host>/<context>/monitoring?action=mail_test

** 15. Utilisateur base de données

	Depuis la page html du monitoring, il est possible d'accéder à des informations et à des
	statistiques sur la base de données (si postgresql, mysql ou oracle),
	comme par exemple les requêtes sql en cours ou si oracle, les requêtes les plus longues en temps cumulé
	avec indication du temps cpu et du coût élémentaire (en buffer gets).
	
	Pour cela l'utilisateur en base de données configuré dans l'application monitorée doit avoir
	les droits nécessaires pour lire ces informations et statistiques. C'est-à-dire le droit
	d'exécuter la requête <<<select * from pg_stat_activity>>> dans postgresql, ou la requête
	<<<show full processlist>>> dans mysql ou la requête <<<select * from v$session>>> dans oracle.
	
	L'utilisateur en base de données utilisé dans l'application monitorée doit se voir accordé les
	droits nécessaires s'il ne les a pas déjà. Par exemple, sous oracle vous pouvez exécuter la requête
	sql suivante en tant qu'utilisateur 'system' pour accorder le droit à l'utilisateur 'myapplication' :
	<<<grant select any dictionary to myapplication>>>

** 16. Sécurité

	La page de monitoring étant uniquement en consultation et ne contenant pas d'informations comme login ou mot de passe,
	il n'est pas absolument nécessaire que cette page soit en accès restreint. Toutefois, il est possible de restreindre
	son accès par une expression régulière sur l'adresse ip du client avec le paramètre <<<allowed-addr-pattern>>>
	(expression régulière avec une plage d'adresses ip internes ou des adresses ip fixes d'administrateurs).
	Par exemple, "172\.16\..*" pour autoriser les adresses IP comme "172.16.x.y".
	Ce paramètre se définit comme les autres paramètres ci-dessus.
	
	Si des <<<security-constraint>>> et <<<security-role>>>(s) sont définis dans le fichier <<<web.xml>>> de l'application, il vous est
	également possible dans ce fichier <<<web.xml>>> de restreindre l'accès à la page de monitoring au rôle "monitoring" par exemple
	(sauf si un serveur de collecte est utilisé comme indiqué dans le chapitre suivant, auquel cas il convient d'utiliser
	le paramètre allowed-addr-pattern).
	
	Exemple de contenu du fichier web.xml pour authentification par identifiant et mot de passe :
	
+-------------------------------+
	<login-config>
		<auth-method>BASIC</auth-method>
		<realm-name>Monitoring</realm-name>
	</login-config>
	<security-role>
		<role-name>monitoring</role-name>
	</security-role>
	<security-constraint>
		<web-resource-collection>
			<web-resource-name>Monitoring</web-resource-name>
			<url-pattern>/monitoring</url-pattern>
		</web-resource-collection>
		<auth-constraint>
			<role-name>monitoring</role-name>
		</auth-constraint>
		<!-- si activation cryptage SSL (ce qui nécessite la configuration de SSL et du certificat dans le serveur)
		<user-data-constraint>
			<transport-guarantee>CONFIDENTIAL</transport-guarantee>
		</user-data-constraint> 
		-->
	</security-constraint>
+-------------------------------+

	Le royaume et les utilisateurs doivent être définis dans le serveur d'application,
	et les utilisateurs doivent avoir le rôle "monitoring" pour avoir accès aux rapports.
	Par exemple, si tomcat est utilisé avec le royaume par défaut, modifiez le contenu du fichier tomcat conf/tomcat-users.xml ainsi :
	
+-------------------------------+
<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
  <role rolename="monitoring"/>
  <user username="monitoring" password="monitoring" roles="monitoring"/>
</tomcat-users>
+-------------------------------+

** 17. SecurityManager

	Si vous êtes l'une des rares personnes avec un SecurityManager activé dans votre serveur,
	il y aura une exception comme celle ci-dans la sortie du serveur au démarrage de la webapp
	avec JavaMelody : "java.security.AccessControlException: access denied ...".
	
	Et cela car JavaMelody a besoin d'un accès à de nombreuses informations systèmes et elle a
	besoin d'écrire ses fichiers. Pour que JavaMelody fonctionne, vous pouvez désactiver le
	SecurityManager (Si Tomcat, enlever l'option
	{{{http://tomcat.apache.org/tomcat-6.0-doc/security-manager-howto.html}-security}} du démarrage)
	ou si vous voulez le conserver, vous pouvez modifier le fichier
	{{{http://java.sun.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#Examples}java.policy}}
	de votre serveur.
	
	Par exemple avec Tomcat, le fichier java.policy est $CATALINA_HOME/conf/catalina.policy
	et vous pouvez ajouter quelque chose comme l'exemple suivant pour accorder l'accès aux fichiers
	jar de JavaMelody et de JRobin :

+-------------------------------+
	grant codeBase "file:${catalina.home}/webapps/<votre_webapp>/WEB-INF/lib/javamelody-x.jar" {
		permission java.security.AllPermission;
	};
	grant codeBase "file:${catalina.home}/webapps/<votre_webapp>/WEB-INF/lib/jrobin-1.5.9.1.jar" {
		permission java.security.AllPermission;
	};
+-------------------------------+
	
	en remplaçant <<< <votre_webapp> >>> par le nom de votre webapp et en remplaçant
	<<<javamelody-x.jar>>> par le nom exact du fichier jar de JavaMelody.


** 18. Résultat complet

	Pour consulter le monitoring, déployer le war et ouvrir la page suivante dans un navigateur web après avoir démarré le serveur :

	<<<http://<host>/<context>/monitoring>>>
	
	où <host> est le nom du serveur où la webapp est déployée, suivi éventuellement du port (par exemple localhost:8080)
	et où <context> est le nom du contexte de la webapp que vous avez configuré au moment du déploiement de celle-ci.

* Dépendances
	
	Si vous n'avez pas Maven2, les fichiers jar peuvent être trouvés dans le fichier zip,
	disponible dans la partie "Download", à l'intérieur du répertoire racine et du répertoire 
	<<<src/test/test-webapp/WEB-INF/lib>>>
	
	Si vous avez Maven2, vous pouvez utiliser les dépendances <<<javamelody-core>>>,
	(<<<jrobin>>> est inclus transitivement avec javamelody-core),
	et optionnellement <<<itext>>> pour ajouter l'export PDF,
	ainsi que les dépôts suivants dans votre fichier <<<pom.xml>>> :

+-------------------------------+
	<!-- javamelody-core -->
	<dependency>
		<groupId>net.bull.javamelody</groupId>
		<artifactId>javamelody-core</artifactId>
		<version>1.30.0</version>
	</dependency>
	<!-- itext, option to add PDF export -->
	<dependency>
		<groupId>com.lowagie</groupId>
		<artifactId>itext</artifactId>
		<version>2.1.7</version>
		<exclusions>
			<exclusion>
				<artifactId>bcmail-jdk14</artifactId>
				<groupId>bouncycastle</groupId>
			</exclusion>
			<exclusion>
				<artifactId>bcprov-jdk14</artifactId>
				<groupId>bouncycastle</groupId>
			</exclusion>
			<exclusion>
				<artifactId>bctsp-jdk14</artifactId>
				<groupId>bouncycastle</groupId>
			</exclusion>
		</exclusions>
	</dependency>
	...
	<repositories>
		<!-- for javamelody and for jrobin -->
		<repository>
			<id>m.g.o-public</id>
			<url>http://maven.glassfish.org/content/groups/public/</url>
			<releases>
				<enabled>true</enabled>
			</releases>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</repository>
	</repositories>
+-------------------------------+

	Les dépendances jrobin (inclus avec javamelody-core) et si souhaité <<<xstream>>>
	comme option pour la communication avec le serveur de collecte sont:

+-------------------------------+
	<dependency>
		<groupId>com.thoughtworks.xstream</groupId>
		<artifactId>xstream</artifactId>
		<version>1.3.1</version>
	</dependency>
	<dependency>
		<groupId>org.jrobin</groupId>
		<artifactId>jrobin</artifactId>
		<version>1.5.9</version>
	</dependency>
+-------------------------------+

* Documentation avancée (mise en oeuvre avec un ear, serveur de collecte centralisé, JBoss AS 7, JonAS 5, logs de débogage...)

	Pour mettre en oeuvre JavaMelody avec un ear, pour déployer un serveur de collecte centralisé,
	pour utiliser JBoss AS 7, JonAS 5 ou pour activer les logs de débogage,
	consulter la {{{user_guide_advanced.html} documentation avancée}}
	
* Compilation et développement

	{{{dev_guide.html} Guide du dévelopeur}}